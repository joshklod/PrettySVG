#!/usr/bin/perl

use strict;
use warnings;
use autodie;

my $match_string   = qr/'[^']*'|"[^"]*"/;

my $indent        = 2;
my $indent_attr   = 3;

if ($indent        =~ /^\d+$/) { $indent        = ' ' x $indent; }
if ($indent_attr   =~ /^\d+$/) { $indent_attr   = ' ' x $indent_attr; }

my $level     = 0;
my $in_text   = 0;

{
	my ($line, @chars);
	my $idx    = 0;

	sub getline {
		if ($idx > $#chars) {
			$line = <>;
			unless ($line) { $line = ""; }
			@chars  = split(//, $line);
			$idx    = 0;
		}
	}

	sub nextchar {
		my ($c) = @_;

		getline();

		if ($#chars == -1) {
			return 0;
		} elsif (length $c) {
			return ($chars[$idx] eq $c);
		} else {
			return 1;
		}
	}

	sub getmatch {
		my ($regex) = @_;
		unless (ref $regex eq 'Regexp') {
			$regex = qr/\Q$regex\E/;
		}

		getline();

		my ($match) = substr($line, $idx) =~ /^($regex)/;
		if ($match) {
			$idx += length($match);
		} else {
			$match = '';
		}

		return $match;
	}

	sub find_match {
		my ($regex, $skip_str) = @_;
		unless (defined $skip_str) { $skip_str = 0; }
		unless (ref $regex eq 'Regexp') {
			$regex = qr/\Q$regex\E/;
		}
		my $match;

		my $dot = $skip_str ? qr/(?>$match_string|.)/ : qr/./;

		my $result = '';
		while (nextchar()) {
			if ($match = getmatch(qr/$dot*?$regex/)) {
				$result .= $match;
				last;
			} else {
				$result .= getmatch(qr/.*/s);
			}
		}
		return $result;
	}
}

sub attr_sort {
	sub priority {
		my ($attr) = @_;
		my @order = ('id', qr/^xmlns(?:\:.*)?$/, 'x', 'y', 'width', 'height');

		my ($name) = $attr =~ /^([^=]*)/;

		for (my $idx = 0; $idx <= $#order; $idx++) {
			my $pat = $order[$idx];
			if (ref $pat eq 'Regexp' ? $name =~ $pat : $name eq $pat) {
				return $idx;
			}
		}
		return $#order + 1;
	}

	# Fall back to alphabetical sort if priority is equal
	return ((priority($a) <=> priority($b)) or ($a cmp $b));
}

sub find_tag {
	my $text = '';
	while (nextchar() && !nextchar('<')) {
		$text .= getmatch(qr/[^<]*/);
	}

	unless ($in_text) {
		if ($text =~ /\S/) {
			$text =~ s/^\s*\n|\s+$//g; # Strip leading/trailing blank lines
			$text =~ s/[[:blank:]]+$//mg;

			# Use indent of first line as reference
			my ($old_indent) = $text =~ /^(\s*)/;
			$text =~ s/^\Q$old_indent\E/$indent x $level/emg;

			$text .= "\n";
		} else {
			$text = '';
		}
	}

	print $text;
	return nextchar('<');
}

sub parse_tag {
	my $tag             = '';
	my $tag_open        = 0;
	my $in_text_after   = $in_text;
	my @attrs;

	if      ($tag = getmatch('<!--')) {
		$tag .= find_match('-->');
	} elsif ($tag = getmatch('<?')) {
		$tag .= find_match('?>');
	} elsif ($tag = getmatch('<![CDATA[')) {
		$tag .= find_match(']]>');
	} elsif ($tag = getmatch('</')) {
		$tag .= find_match('>');

		$tag =~ s/\s*>$/>/;

		$level-- unless ($level == 0);
		if ($tag =~ m{^</text\b}) { $in_text_after = 0; }
	} else {
		$tag .= find_match('>', 1);

		my $end = $tag =~ s{(/?>)$}{} ? $1 : '';

		$tag =~ s/\s+$//;

		while ($tag =~ s/\s+(\S*)\s*=\s*($match_string|\S*)//) {
			push(@attrs, "$1=$2");
		}
		while ($tag =~ s/\s+(\S+)//) {
			push(@attrs, $1);
		}
		@attrs = sort attr_sort @attrs;

		$tag = join("\n".($indent x $level).$indent_attr,
				($tag, @attrs, $end));

		if ($end eq '/>') {
			$tag =~ s{\s*/>$}{ />};
		} else {
			$tag_open = 1;
			$tag =~ s{\s*>$}{>};
			if ($tag =~ /^<text\b/) { $in_text_after = 1; }
		}
	}

	unless ($in_text) { $tag = ($indent x $level) . $tag; }
	$in_text = $in_text_after;
	unless ($in_text) { $tag .= "\n"; }

	print $tag;
	if ($tag_open) { $level++; }
}

while (nextchar()) {
	find_tag() and parse_tag();
}

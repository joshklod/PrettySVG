#!/usr/bin/perl

use strict;
use warnings;
use autodie;

my $match_string   = qr/'[^']*'|"[^"]*"/;

my $indent        = 2;
my $indent_attr   = 3;

if ($indent        =~ /^\d+$/) { $indent        = ' ' x $indent; }
if ($indent_attr   =~ /^\d+$/) { $indent_attr   = ' ' x $indent_attr; }

my $level     = 0;
my $in_text   = 0;

{
	my ($line, @chars);
	my $idx    = 0;

	sub getline {
		if ($idx > $#chars) {
			$line = <>;
			unless ($line) { $line = ""; }
			@chars  = split(//, $line);
			$idx    = 0;
		}
	}

	sub nextchar {
		my ($c) = @_;

		getline();

		if ($#chars == -1) {
			return 0;
		} elsif (length $c) {
			return ($chars[$idx] eq $c);
		} else {
			return 1;
		}
	}

	sub getmatch {
		my ($regex) = @_;
		unless (ref $regex eq 'Regexp') {
			$regex = qr/\Q$regex\E/;
		}

		getline();

		my ($match) = substr($line, $idx) =~ /^($regex)/;
		if ($match) {
			$idx += length($match);
		} else {
			$match = '';
		}

		return $match;
	}

	sub find_match {
		my ($regex, $skip_str) = @_;
		unless (defined $skip_str) { $skip_str = 0; }
		unless (ref $regex eq 'Regexp') {
			$regex = qr/\Q$regex\E/;
		}
		my $match;

		my $dot = $skip_str ? qr/(?>$match_string|.)/ : qr/./;

		my $result = '';
		while (nextchar()) {
			if ($match = getmatch(qr/$dot*?$regex/)) {
				$result .= $match;
				last;
			} else {
				$result .= getmatch(qr/.*/s);
			}
		}
		return $result;
	}
}

sub find_tag {
	my $text = '';
	while (nextchar() && !nextchar('<')) {
		$text .= getmatch(qr/[^<]*/);
	}

	unless ($in_text) {
		if ($text =~ /\S/) {
			$text =~ s/^\s*\n|\s+$//g; # Strip leading/trailing blank lines
			$text =~ s/[[:blank:]]+$//mg;

			# Use indent of first line as reference
			my ($old_indent) = $text =~ /^(\s*)/;
			$text =~ s/^\Q$old_indent\E/$indent x $level/emg;

			$text .= "\n";
		} else {
			$text = '';
		}
	}

	print $text;
	return nextchar('<');
}

sub parse_tag {
	my $tag        = '';
	my $tag_open   = 0;

	if      ($tag = getmatch('<!--')) {
		$tag .= find_match('-->');
	} elsif ($tag = getmatch('<?')) {
		$tag .= find_match('?>');
	} elsif ($tag = getmatch('<![CDATA[')) {
		$tag .= find_match(']]>');
	} elsif ($tag = getmatch('</')) {
		$tag .= find_match('>');

		$tag =~ s/\s*>$/>/;

		$level-- unless ($level == 0);
	} else {
		$tag .= find_match('>', 1);
		$tag =~ s/\s+(\S+)\s*=\s*($match_string|\S*)/"\n".($indent x $level)."$indent_attr$1=$2"/eg;
		if ($tag =~ m{/>$}) {
			$tag =~ s{\s*/>$}{ />};
		} else {
			$tag_open = 1;
			$tag =~ s{\s*>$}{>};
		}
	}

	unless ($in_text) { $tag = ($indent x $level) . $tag . "\n"; }
	print $tag;

	if ($tag_open) { $level++; }
}

while (nextchar()) {
	find_tag() and parse_tag();
}
